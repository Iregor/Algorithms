/*
У Кати насыщенный день на работе. Ей надо передать n разных договоров коллегам.
Все встречи происходят на разных этажах, а между этажами можно перемещаться только по лестничным пролетам — считается,
что это улучшает физическую форму сотрудников. Прохождение каждого пролета занимает ровно 1 минуту.

Сейчас Катя на парковочном этаже, планирует свой маршрут. Коллег можно посетить в любом порядке,
но один из них покинет офис через t минут. С парковочного этажа лестницы нет — только лифт, на котором можно подняться на
любой этаж.

В итоге план Кати следующий:

Подняться на лифте на произвольный этаж. Считается, что лифт поднимается на любой этаж за 0 минут.
Передать всем коллегам договоры, перемещаясь между этажами по лестнице. Считается, что договоры на этаже передаются мгновенно.
В первые t минут передать договор тому коллеге, который планирует уйти.
Пройти минимальное количество лестничных пролетов.
Помогите Кате выполнить все пункты ее плана.

Формат входных данных

В первой строке вводятся целые положительные числа
n и t — количество сотрудников и время, когда один из сотрудников покинет офис (в минутах).
В следующей строке n чисел — номера этажей, на которых находятся сотрудники.
Все числа различны и по абсолютной величине не превосходят 100. Номера этажей даны в порядке возрастания.
В следующей строке записан номер сотрудника, который уйдет через t минут.

Формат выходных данных

Выведите одно число — минимально возможное число лестничных пролетов, которое понадобится пройти Кате.
*/

package tinkoff.permanentContest;

import java.io.*;
import java.util.*;

public class KateAndStages {
    public static void main(String[] args) throws IOException {
        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {
            String[] line = br.readLine().split(" ");
            int emploee = Integer.valueOf(line[0]);
            int time = Integer.valueOf(line[1]);
            int[] stages = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::valueOf).toArray();
            int emplLeave = Integer.valueOf(br.readLine());
            int headTime = stages[emplLeave - 1] - stages[0];
            int tailTime = stages[stages.length - 1] - stages[emplLeave - 1];
            if (headTime <= time || tailTime <= time) {
                System.out.println(stages[stages.length - 1] - stages[0]);
            } else {
                System.out.println(Integer.min(headTime, tailTime) + stages[stages.length - 1] - stages[0]);
            }
        }
    }
}